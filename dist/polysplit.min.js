!function(n,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(n="undefined"!=typeof globalThis?globalThis:n||self).polysplit=t()}(this,(function(){"use strict";var n=i,t=i;function i(n,t){if(!(this instanceof i))return new i(n,t);if(this.data=n||[],this.length=this.data.length,this.compare=t||e,this.length>0)for(var o=(this.length>>1)-1;o>=0;o--)this._down(o)}function e(n,t){return n<t?-1:n>t?1:0}function o(n,t){return n.minX>t.minX?1:n.minX<t.minX?-1:n.minY>t.minY?1:n.minY<t.minY?-1:1}i.prototype={push:function(n){this.data.push(n),this.length++,this._up(this.length-1)},pop:function(){if(0!==this.length){var n=this.data[0];return this.length--,this.length>0&&(this.data[0]=this.data[this.length],this._down(0)),this.data.pop(),n}},peek:function(){return this.data[0]},_up:function(n){for(var t=this.data,i=this.compare,e=t[n];n>0;){var o=n-1>>1,p=t[o];if(i(e,p)>=0)break;t[n]=p,n=o}t[n]=e},_down:function(n){for(var t=this.data,i=this.compare,e=this.length>>1,o=t[n];n<e;){var p=1+(n<<1),s=p+1,l=t[p];if(s<this.length&&i(t[s],l)<0&&(p=s,l=t[s]),i(l,o)>=0)break;t[n]=l,n=p}t[n]=o}},n.default=t;class p{constructor(n,t,i,e){this.p1=n,this.p2=t,this.edgeType=i,this.originalIndex=e,this.minX=Math.min(n.p[0],t.p[0]),this.minY=Math.min(n.p[1],t.p[1]),this.maxX=Math.max(n.p[0],t.p[0]),this.maxY=Math.max(n.p[1],t.p[1]),this.intersectionPoints=[]}}class s{constructor(n){this.p=n,this.nextPoint=null,this.prevPoint=null,this.visited=!1,this.intersectionPoints=[]}}function l(n,t){return!(n.maxX<t[0])&&(!(n.minX>t[2])&&(!(n.maxY<t[1])&&!(n.minY>t[3])))}let h=0;class r{constructor(n,t,i){this.p=n,this.polylineEdge=t,this.polygonEdge=i,this.isPolylineHeadingIn=h%2==0,this.visited=!1,this.pair=null,this.ip=h,h+=1,this.polygonEdge.intersectionPoints.push(this)}}function a(n,t){return n[0]*t[1]-n[1]*t[0]}function u(n,t){return n[0]*t[0]+n[1]*t[1]}function f(n,t,i){return[n[0]+t*i[0],n[1]+t*i[1]]}function c(n,t,i){var e=[n.p2.p[0]-n.p1.p[0],n.p2.p[1]-n.p1.p[1]],o=[t.p2.p[0]-t.p1.p[0],t.p2.p[1]-t.p1.p[1]],p=[t.p1.p[0]-n.p1.p[0],t.p1.p[1]-n.p1.p[1]],s=a(e,o),l=s*s,h=u(e,e);u(o,o);if(l>0){var r=a(p,o)/s;if(r<0||r>1)return null;var c=a(p,e)/s;return c<0||c>1?null:0===r||1===r?i?null:[f(n.p1.p,r,e)]:0===c||1===c?i?null:[f(t.p1.p,c,o)]:[f(n.p1.p,r,e)]}var g=u(p,p);if((l=(s=a(p,e))*s)>1e-9*h*g)return null;var d=u(e,p)/h,m=d+u(e,o)/h,y=Math.min(d,m),x=Math.max(d,m);return y<=1&&x>=0?1===y?i?null:[f(n.p1.p,y>0?y:0,e)]:0===x?i?null:[f(n.p1.p,x<1?x:1,e)]:i&&0===y&&1===x?null:[f(n.p1.p,y>0?y:0,e),f(n.p1.p,x<1?x:1,e)]:null}function g(n,t,i){let e=n===t;for(;e;)i.push(n.p),(null===(n=n.nextPoint)||n!==t)&&(e=!1)}function d(n,t,i){let e=n===t;for(;e;)i.push(n.p),(null===(n=n.prevPoint)||n!==t)&&(e=!1)}return function(t,i){const e=[],h=[],a=[],u=new n(null,o);!function(n,t,i,e,o,h){var r,a,u,f,c,g,d=null;let m=("Feature"===t.type?t.geometry:t).coordinates;const y=m.length-1;for(c=new s(m[0]),r=0;r<y;r++)g=new s(m[r+1]),c.nextPoint=g,g.prevPoint=c,e.push(new p(c,g,"polyline",r)),o[0]=Math.min(o[0],c.p[0]),o[1]=Math.min(o[1],c.p[1]),o[2]=Math.max(o[2],c.p[0]),o[3]=Math.max(o[3],c.p[1]),c=g;o[0]=Math.min(o[0],m[y][0]),o[1]=Math.min(o[1],m[y][1]),o[2]=Math.max(o[2],m[y][0]),o[3]=Math.max(o[3],m[y][1]);let x=("Feature"===n.type?n.geometry:n).coordinates;for(r=0,a=x.length;r<a;r++){f=x[r];const n=[];for(c=new s(f[0]),n.push(c),u=1;u<f.length;u++)g=new s(f[u]),c.nextPoint=g,g.prevPoint=c,(d=new p(c,g,"polygon",u-1)).intersectPolylineBbox=l(d,o),i.push(d),h.push(d),c=g;(d=new p(c,n[0],"polygon",u-1)).intersectPolylineBbox=l(d,o),i.push(d),h.push(d),g.nextPoint=n[0],n[0].prevPoint=g.prevPoint}}(t,i,h,a,[1/0,1/0,1/0,1/0],u);const f=[];for(;u.length;)f.push(u.pop());!function(n,t,i){let e,o,p,s=t.length,l=n.length;for(e=0;e<s;e++){let s=t[e];for(o=0;o<l;o++){const t=n[o];if(!t.intersectPolylineBbox)continue;if(t.maxX<s.minX||t.minX>s.maxX)continue;if(t.maxY<s.minY||t.minY>s.maxY)continue;const e=c(s,t);if(null!==e)for(p=0;p<e.length;p++){var h=new r(e[p],s,t);i.push(h)}}}}(h,a,e);for(var m=0;m<e.length;m++)e[m].pair=m%2==0?e[m+1]:e[m-1];let y=[];const x=[y],v=new Map;for(let n=0;n<h.length;n++){const t=h[n],i=t.p1;y.push(i.p),t.intersectionPoints.length>0&&t.intersectionPoints.forEach((function(n){y.push(n.p);const t=n.pair;if(v.set(t.polygonEdge.originalIndex,{usedIn:y}),v.has(n.polygonEdge.originalIndex)){const i=v.get(n.polygonEdge.originalIndex);if(y=i.usedIn,n.isPolylineHeadingIn){g(n.polylineEdge.p2,t.polylineEdge.p1,y)}else{d(n.polylineEdge.p1,t.polylineEdge.p2,y)}}else{const i=[];if(x.push(i),y=i,y.push(t.p),n.isPolylineHeadingIn){g(n.polylineEdge.p2,t.polylineEdge.p1,y)}else{d(n.polylineEdge.p1,t.polylineEdge.p2,y)}}y.push(n.p)}))}return{type:"Feature",properties:{},geometry:{type:"MultiPolygon",coordinates:[x]}}}}));
